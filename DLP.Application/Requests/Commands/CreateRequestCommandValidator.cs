using FluentValidation;
using DLP.Application.Common.Extensions;
using DLP.Application.Common.Interfaces;
using DLP.Application.Qualifications.Queries;
using DLP.Domain.Enums;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace DLP.Application.Requests.Commands;

public class CreateRequestCommandValidator : AbstractValidator<CreateRequestCommand>
{
    private readonly IAppDbContext _dbContext;
    private readonly IMediator _mediator;
    public CreateRequestCommandValidator(IAppDbContext dbContext, IMediator mediator)
    {
        _dbContext = dbContext;
        _mediator = mediator;

        RuleFor(x => x.Type)
            .NotEmpty().NotNull().WithMessage("Type is required")
            .MustAsync((r, x, _, ca) => BeUniqueHandledRequestType(x, r.CompanyId, ca))
            .WithMessage("There's a pending request for given type, please wait until a decision is taken upon it");

        RuleFor(x => x.ContactPersonEmail)
            .NotEmpty().NotNull().EmailAddress().WithMessage("Email is required")
            .MustAsync((r, x, _, ca) => BeUniqueEmail(x, r.IsFromPublic, ca)).WithMessage("This email already exists!");

        RuleFor(x => x.CompanyName)
            .NotEmpty().NotNull().WithMessage("Company Name is required");

        RuleFor(x => x.IdNumber)
            .NotEmpty().NotNull().WithMessage("Id Number is required")
            .MustAsync((r, x, _, ca) => BeUniqueOrganizationIdNumber(x, r.IsFromPublic, ca))
            .WithMessage("You are already part of the system, login and do requests inside the system")
            .Length(13)
            .WithMessage("Id Number must be 13 characters")
            .When(x => !x.CompanyId.HasValue);

        RuleFor(x => x.TaxNumber)
            .Length(12)
            .WithMessage("Tax Number must be 12 characters");

        //RuleFor(x => x.LicenseId)
        //    .MustAsync((r, x, _, ca) => BeUniqueLicenseId(x, r.CompanyId, ca)).WithMessage("License Id must be unique")
        //    .When(x => !x.IsFromPublic && !x.IsLoggedInAsCompany && x.Type.IsOneOf(
        //        RequestType.RegistrationAndLicensingOfServiceCompanies,
        //        RequestType.RegistrationAndLicensingOfImportersExporters,
        //        RequestType.RequestForExtensionOfLicenseOfServiceCompanies)
        //    );

        RuleFor(x => x.LicenseId)
            .MustAsync((r, x, _, ca) => BeUniqueLicenseId(x, r.CompanyId, ca)).WithMessage("License Id must be unique")
            .When(x => !x.IsFromPublic && !x.IsLoggedInAsCompany && x.Type.IsOneOf(
                RequestType.RegistraterAsShipper,
                RequestType.RegistraterAsCarrier)
            );

        RuleFor(x => x.LicenseId)
            .Null()
            .WithMessage("License Id is autogenerated, do not manually provide it")
            .When(x => x.IsFromPublic || x.IsLoggedInAsCompany);

        RuleFor(x => x.ResponsiblePersonFullName)
            .NotEmpty().NotNull().WithMessage("Responsible Person Full Name is required");

        RuleFor(x => x.ContactPersonFirstName)
            .NotEmpty().NotNull().WithMessage("Contact Person First Name is required");
        RuleFor(x => x.ContactPersonLastName)
            .NotEmpty().NotNull().WithMessage("Contact Person Last Name is required");

        RuleFor(x => x.ContactPersonEmail)
            .NotEmpty().NotNull().EmailAddress().WithMessage("Contact Person Email is required");

        RuleFor(x => x.MunicipalityId)
            .NotEmpty().NotNull().WithMessage("Municipality Id is required");

        RuleFor(x => x.CompanyEmailAddress)
            .NotEmpty().NotNull().EmailAddress().WithMessage("Company Email Address is required");

        //When(x => x.Type == RequestType.RegistrationAndLicensingOfServiceCompanies,
        //    () =>
        //    {
        //        RuleFor(x => x.CompanyType)
        //            .NotEmpty().NotNull().WithMessage("Company Type is required");

        //        RuleFor(x => x.AreaOfExpertise)
        //            .NotEmpty().NotNull().WithMessage("Area Of Expertise is required");

        //        RuleFor(x => x.CertificationNumbers)
        //            .NotNull().WithMessage("Certification Numbers are required")
        //            .Must(certificationNumbers => certificationNumbers?.Count > 0).WithMessage("Certification Numbers are required")
        //            .MustAsync((x, cn, cancellationToken) => BeAvailableCertificateNumbers(cn, x.CompanyId, cancellationToken))
        //            .WithMessage("One or more certificate numbers are not available");

        //        //RuleFor(x => x.MeetsEquipmentRegulations)
        //        //    .NotEmpty().NotNull();

        //        RuleFor(x => x.LicenseId)
        //           .NotEmpty().NotNull().When(x => !x.IsFromPublic && !x.IsLoggedInAsCompany);

        //        RuleFor(x => x.LicenseDuration)
        //            .NotEmpty().NotNull().When(x => !x.IsFromPublic && !x.IsLoggedInAsCompany);
        //    });

        //When(x => x.Type == RequestType.RegistrationAndLicensingOfImportersExporters,
        //() =>
        //{
        //    RuleFor(x => x.CompanyType)
        //        .NotEmpty().NotNull().WithMessage("Company Type is required");

        //    RuleFor(x => x.LicenseId)
        //       .NotEmpty().NotNull().When(x => !x.IsFromPublic && !x.IsLoggedInAsCompany);

        //    RuleFor(x => x.LicenseDuration)
        //        .NotEmpty().NotNull().When(x => !x.IsFromPublic && !x.IsLoggedInAsCompany);
        //});

        //When(x => x.Type == RequestType.RequestForExtensionOfLicenseOfServiceCompanies && x.IsFromPublic,
        //    () =>
        //    {
        //        RuleFor(x => x.Type)
        //            .Must(type => false)
        //            .WithMessage("Request for extension of the license of KGH service companies/entrepreneurs must be inside the system");
        //    });
    }

    public async Task<bool> BeUniqueHandledRequestType(RequestType type, Guid? companyId, CancellationToken cancellationToken)
    {
        if (!companyId.HasValue) return true;
        var pendingRequestTypeExists = await _dbContext.Requests
            .AnyAsync(x => x.Type == type
            && x.CompanyId == companyId
            && x.Status == RequestStatus.Pending, cancellationToken);
        return !pendingRequestTypeExists;
    }

    public async Task<bool> BeUniqueEmail(string email, bool isFromPublic, CancellationToken cancellationToken)
    {
        if (!isFromPublic) return true;
        var userByEmail = await _dbContext.Users.FirstOrDefaultAsync(x => x.Email == email, cancellationToken);
        return userByEmail == null;
    }

    public async Task<bool> BeUniqueOrganizationIdNumber(string idNumber, bool isFromPublic, CancellationToken cancellationToken)
    {
        if (!isFromPublic) return true;
        var organizationByIdNumber = await _dbContext.Organizations.FirstOrDefaultAsync(x => x.IdNumber == idNumber, cancellationToken);
        return organizationByIdNumber == null;
    }

    public async Task<bool> BeUniqueLicenseId(string? licenseId, Guid? companyId, CancellationToken cancellationToken)
    {
        var licenseIdExists = await _dbContext.Organizations.AnyAsync(x => x.LicenseId == licenseId
            && (!companyId.HasValue || (companyId.HasValue && x.Id != companyId)), cancellationToken);
        return !licenseIdExists;
    }
    public async Task<bool> BeAvailableCertificateNumbers(List<string> certificationNumbers, Guid? organizationId, CancellationToken cancellationToken)
    {
        var query = new CheckCertificateNumberAvailabilityQuery
        {
            CertificationNumbers = certificationNumbers,
            OrganizationId = organizationId
        };

        var results = await _mediator.Send(query, cancellationToken);
        return results.All(r => r.IsAvailable);
    }
}